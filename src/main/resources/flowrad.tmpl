// Some overall comments pertaining to flowradar:
// 1. inKey represents the incoming key. evictedKey and evictedValue represent evicted keys and values (if any).
// 2. inKey and evictedKey are of type struct Key_$StageName$. evictedValue is of type struct Value_$StageName$.
// 3. The fields within both structs are named f0, f1, f2, ...
// 4. The reason we use these opaque names (f0) is because the key fields have fully qualified names, e.g., foo.bar.
// 5. And the name key.foo.bar.... doesn't work without resorting to nested structs.

// Based on original FlowRadar P4 implementation:
// https://github.com/harvard-cns/FlowRadar-P4

#define FILTER_SIZE 32w32768

// Template hole: register for each field in key
$KeyFields : { field | register<bit<32>>(32w$TableSize$) regK_$StageName$_f$i0$;$\n$}$

// Template hole: register for each field in value
$ValueFields : { field | register<bit<32>>(32w$TableSize$) regV_$StageName$_f$i0$;$\n$}$

// Template hole: flow filter register
register<bit<1>>(FILTER_SIZE) filter_$StageName$;


// Template hole: action signature for flowradar update step
action $StageName$_update(inout Value_$StageName$ updatedValue) {

    // Extract values from the structure
    $ValueFields : { field | bit<32> _val_$field$ = updatedValue.f$i0$;$\n$}$

    // Template hole: Execute code that updates value registers.
    // The code should reference values by their _val_* variable names directly.
    $UpdateCode$

    // Pack values into the structure again
    $ValueFields : { field | updatedValue.f$i0$ = _val_$field$;$\n$}$
}


// Template hole: action signature for flowradar
action $StageName$(inout Key_$StageName$ evictedKey, inout Value_$StageName$ evictedValue) {

    // Template hole: Populate inKey's fields from the current packet.
    Key_$StageName$ inKey;
    $KeyFields: { field | inKey.f$i0$ = $field$;$\n$}$

    // Filter hashes variables
    bit<32> filter_hash00 = 32w0;
    bit<32> filter_hash01 = 32w0;
    bit<32> filter_hash02 = 32w0;
    bit<32> filter_hash03 = 32w0;
    bit<32> filter_hash04 = 32w0;
    bit<32> filter_hash05 = 32w0;
    bit<32> filter_hash06 = 32w0;
    bit<32> filter_hash07 = 32w0;
    bit<32> filter_hash08 = 32w0;
    bit<32> filter_hash09 = 32w0;
    bit<32> filter_hash10 = 32w0;
    bit<32> filter_hash11 = 32w0;
    bit<32> filter_hash12 = 32w0;
    bit<32> filter_hash13 = 32w0;
    bit<32> filter_hash14 = 32w0;
    bit<32> filter_hash15 = 32w0;
    bit<32> filter_hash16 = 32w0;
    bit<32> filter_hash17 = 32w0;
    bit<32> filter_hash18 = 32w0;
    bit<32> filter_hash19 = 32w0;

    // Compute filter hashes from inKey
    hash(filter_hash00, HashAlgorithm.crc32_custom, 32w0, inKey, FILTER_SIZE);
    hash(filter_hash01, HashAlgorithm.crc32_custom, 32w0, inKey, FILTER_SIZE);
    hash(filter_hash02, HashAlgorithm.crc32_custom, 32w0, inKey, FILTER_SIZE);
    hash(filter_hash03, HashAlgorithm.crc32_custom, 32w0, inKey, FILTER_SIZE);
    hash(filter_hash04, HashAlgorithm.crc32_custom, 32w0, inKey, FILTER_SIZE);
    hash(filter_hash05, HashAlgorithm.crc32_custom, 32w0, inKey, FILTER_SIZE);
    hash(filter_hash05, HashAlgorithm.crc32_custom, 32w0, inKey, FILTER_SIZE);
    hash(filter_hash07, HashAlgorithm.crc32_custom, 32w0, inKey, FILTER_SIZE);
    hash(filter_hash08, HashAlgorithm.crc32_custom, 32w0, inKey, FILTER_SIZE);
    hash(filter_hash09, HashAlgorithm.crc32_custom, 32w0, inKey, FILTER_SIZE);
    hash(filter_hash10, HashAlgorithm.crc32_custom, 32w0, inKey, FILTER_SIZE);
    hash(filter_hash11, HashAlgorithm.crc32_custom, 32w0, inKey, FILTER_SIZE);
    hash(filter_hash12, HashAlgorithm.crc32_custom, 32w0, inKey, FILTER_SIZE);
    hash(filter_hash13, HashAlgorithm.crc32_custom, 32w0, inKey, FILTER_SIZE);
    hash(filter_hash14, HashAlgorithm.crc32_custom, 32w0, inKey, FILTER_SIZE);
    hash(filter_hash15, HashAlgorithm.crc32_custom, 32w0, inKey, FILTER_SIZE);
    hash(filter_hash16, HashAlgorithm.crc32_custom, 32w0, inKey, FILTER_SIZE);
    hash(filter_hash17, HashAlgorithm.crc32_custom, 32w0, inKey, FILTER_SIZE);
    hash(filter_hash18, HashAlgorithm.crc32_custom, 32w0, inKey, FILTER_SIZE);
    hash(filter_hash19, HashAlgorithm.crc32_custom, 32w0, inKey, FILTER_SIZE);

    // Check new flow
    bit<1> flow_new = 1w1;
    bit<1> flow_tmp = 1w0;
    filter_$StageName$.read(flow_tmp, filter_hash00);
    flow_new = flow_new & flow_tmp;
    filter_$StageName$.read(flow_tmp, filter_hash01);
    flow_new = flow_new & flow_tmp;
    filter_$StageName$.read(flow_tmp, filter_hash02);
    flow_new = flow_new & flow_tmp;
    filter_$StageName$.read(flow_tmp, filter_hash03);
    flow_new = flow_new & flow_tmp;
    filter_$StageName$.read(flow_tmp, filter_hash04);
    flow_new = flow_new & flow_tmp;
    filter_$StageName$.read(flow_tmp, filter_hash05);
    flow_new = flow_new & flow_tmp;
    filter_$StageName$.read(flow_tmp, filter_hash06);
    flow_new = flow_new & flow_tmp;
    filter_$StageName$.read(flow_tmp, filter_hash07);
    flow_new = flow_new & flow_tmp;
    filter_$StageName$.read(flow_tmp, filter_hash08);
    flow_new = flow_new & flow_tmp;
    filter_$StageName$.read(flow_tmp, filter_hash09);
    flow_new = flow_new & flow_tmp;
    filter_$StageName$.read(flow_tmp, filter_hash10);
    flow_new = flow_new & flow_tmp;
    filter_$StageName$.read(flow_tmp, filter_hash11);
    flow_new = flow_new & flow_tmp;
    filter_$StageName$.read(flow_tmp, filter_hash12);
    flow_new = flow_new & flow_tmp;
    filter_$StageName$.read(flow_tmp, filter_hash13);
    flow_new = flow_new & flow_tmp;
    filter_$StageName$.read(flow_tmp, filter_hash14);
    flow_new = flow_new & flow_tmp;
    filter_$StageName$.read(flow_tmp, filter_hash15);
    flow_new = flow_new & flow_tmp;
    filter_$StageName$.read(flow_tmp, filter_hash16);
    flow_new = flow_new & flow_tmp;
    filter_$StageName$.read(flow_tmp, filter_hash17);
    flow_new = flow_new & flow_tmp;
    filter_$StageName$.read(flow_tmp, filter_hash18);
    flow_new = flow_new & flow_tmp;
    filter_$StageName$.read(flow_tmp, filter_hash19);
    flow_new = flow_new & flow_tmp;

    // Create flow mask
    bit<32> flow_mask = 32w0 - (flow_new == 1 ? 32w0 : 32w1);

    // Update flow filter
    filter_$StageName$.write(filter_hash00, 1);
    filter_$StageName$.write(filter_hash01, 1);
    filter_$StageName$.write(filter_hash02, 1);
    filter_$StageName$.write(filter_hash03, 1);
    filter_$StageName$.write(filter_hash04, 1);
    filter_$StageName$.write(filter_hash05, 1);
    filter_$StageName$.write(filter_hash06, 1);
    filter_$StageName$.write(filter_hash07, 1);
    filter_$StageName$.write(filter_hash08, 1);
    filter_$StageName$.write(filter_hash09, 1);
    filter_$StageName$.write(filter_hash10, 1);
    filter_$StageName$.write(filter_hash11, 1);
    filter_$StageName$.write(filter_hash12, 1);
    filter_$StageName$.write(filter_hash13, 1);
    filter_$StageName$.write(filter_hash14, 1);
    filter_$StageName$.write(filter_hash15, 1);
    filter_$StageName$.write(filter_hash16, 1);
    filter_$StageName$.write(filter_hash17, 1);
    filter_$StageName$.write(filter_hash18, 1);
    filter_$StageName$.write(filter_hash19, 1);

    // Table hashes variables
    bit<32> table_hash00 = 32w0;
    bit<32> table_hash01 = 32w0;
    bit<32> table_hash02 = 32w0;
    bit<32> table_hash03 = 32w0;

    // Compute table hashes from inKey
    hash(table_hash00, HashAlgorithm.crc32_custom, 32w0, inKey, 32w$TableSize$ / 4);
    hash(table_hash01, HashAlgorithm.crc32_custom, 32w0, inKey, 32w$TableSize$ / 4);
    hash(table_hash02, HashAlgorithm.crc32_custom, 32w0, inKey, 32w$TableSize$ / 4);
    hash(table_hash03, HashAlgorithm.crc32_custom, 32w0, inKey, 32w$TableSize$ / 4);

    // Temporary variables for key and values from table
    Key_$StageName$ key_tmp;
    Value_$StageName$ value_tmp;

    // Update key for hash 00
    $KeyFields : { field | regK_$StageName$_f$i0$.read(key_tmp.f$i0$, table_hash00);$\n$}$
    $KeyFields : { field | key_tmp.f$i0$ = key_tmp.f$i0$ ^ (flow_mask & inKey.f$i0$);$\n$}$
    $KeyFields : { field | regK_$StageName$_f$i0$.write(table_hash00, key_tmp.f$i0$);$\n$}$

    // Update key for hash 01
    $KeyFields : { field | regK_$StageName$_f$i0$.read(key_tmp.f$i0$, table_hash01);$\n$}$
    $KeyFields : { field | key_tmp.f$i0$ = key_tmp.f$i0$ ^ (flow_mask & inKey.f$i0$);$\n$}$
    $KeyFields : { field | regK_$StageName$_f$i0$.write(table_hash01, key_tmp.f$i0$);$\n$}$

    // Update key for hash 02
    $KeyFields : { field | regK_$StageName$_f$i0$.read(key_tmp.f$i0$, table_hash02);$\n$}$
    $KeyFields : { field | key_tmp.f$i0$ = key_tmp.f$i0$ ^ (flow_mask & inKey.f$i0$);$\n$}$
    $KeyFields : { field | regK_$StageName$_f$i0$.write(table_hash02, key_tmp.f$i0$);$\n$}$

    // Update key for hash 03
    $KeyFields : { field | regK_$StageName$_f$i0$.read(key_tmp.f$i0$, table_hash03);$\n$}$
    $KeyFields : { field | key_tmp.f$i0$ = key_tmp.f$i0$ ^ (flow_mask & inKey.f$i0$);$\n$}$
    $KeyFields : { field | regK_$StageName$_f$i0$.write(table_hash03, key_tmp.f$i0$);$\n$}$

    // Update value for hash 00
    $ValueFields : { field | regV_$StageName$_f$i0$.read(value_tmp.f$i0$, table_hash00);$\n$}$
    $StageName$_update(value_tmp);
    $ValueFields : { field | regV_$StageName$_f$i0$.write(table_hash00, value_tmp.f$i0$);$\n$}$

    // Update value for hash 01
    $ValueFields : { field | regV_$StageName$_f$i0$.read(value_tmp.f$i0$, table_hash00);$\n$}$
    $StageName$_update(value_tmp);
    $ValueFields : { field | regV_$StageName$_f$i0$.write(table_hash00, value_tmp.f$i0$);$\n$}$

    // Update value for hash 02
    $ValueFields : { field | regV_$StageName$_f$i0$.read(value_tmp.f$i0$, table_hash00);$\n$}$
    $StageName$_update(value_tmp);
    $ValueFields : { field | regV_$StageName$_f$i0$.write(table_hash00, value_tmp.f$i0$);$\n$}$

    // Update value for hash 03
    $ValueFields : { field | regV_$StageName$_f$i0$.read(value_tmp.f$i0$, table_hash00);$\n$}$
    $StageName$_update(value_tmp);
    $ValueFields : { field | regV_$StageName$_f$i0$.write(table_hash00, value_tmp.f$i0$);$\n$}$


    // FlowRadar doesn't have any evicted item, null output variables
    $KeyFields   : { field | evictedKey.f$i0$   = 0;$\n$}$
    $ValueFields : { field | evictedValue.f$i0$ = 0;$\n$}$
}